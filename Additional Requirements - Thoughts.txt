This is the Contents of the c file i used to run the code mentioned above.

#include <stdio.h>
int main() {
    printf("hello world");
    return 0;
}

I need help with a few things to be more specific:

modifications that needs to be enhnaced in def check_indentation() that needs to be added is:
- I need to add a check to Skip checking empty lines and user comments.
- if there is any line that starts with #include in .c file should start without spacing
- after all the #include or library lines are checked, the next line should also need not have any spacing before it. 
- Global variables which will be in the format: datatype + variable name and ths ends  with a semicolon (;)
- datatype + function name + (), it should be followed by {  on the same line after a space
- function definition should have the intendation of 4 spaces per line till } is encountered where it should be after the entire function definition and this should not have any spacing before the same.
- now within this function if there is any control structures in C or perl programming scripts like:

For c scripts:
    For Loop
    While Loop
    Do-While Loop
    If-Else Statement
    If-Else Ladder
    Relational Operators
For Perl scripts:
    For Loop
    Foreach Loop
    While Loop
    Do-While Loop
    If-Else Statement
    If-Elsif-Else Ladder
    Unless Statement
    Unless-Else Statement
    Unless-Elsif Statement

Please note that such examples need to be handled by the code: in the if-else and ladder or nested statements, we need to check indentation where for example:
if (test_expression1) {
    // Statements
} else {
    // Statements
}

in case of if- else if - else ladder scenario
if (test_expression1) {
    // Statements
} else if (test_expression2) {
    // Statements
} else if (test_expression3) {
    // Statements
} else {
    // Statements
}

in case of nested if-else:
if (condition1) {
    // Executes when condition1 is true
    if (condition2) {
        // Executes when condition2 is true
    } else {
        // Executes when condition2 is false
    }
} else {
    // Executes when condition1 is false
}


-------------------------------------------------------------------

#include <stdio.h>
int main() {
    printf("hello world");
    return 0;
}

There is no spaces before #include, but the error is thrown. 
Also int main is correctly spaced, since it is a function or a main function call. This should be the same with globally declared variables as well.
after int main, it is followed by () and a space and { after which the block of code starts on a new line with 4 space indent which is how it should be and the statements need to end with


It looks like the script is running successfully and performing the desired analysis. Here's a breakdown of the issues found:

Indentation issue at line 1: Incorrect indentation for #include.
Syntax issue at line 1: Incorrect syntax after #include.
Indentation issue at lines 2, 3, and 4: Incorrect indentation.
Consistency issue at line 5: Inconsistent line ending.
Whitespace issue at lines 3 and 4: Excessive whitespace within line.
The script successfully completed the analysis after identifying these issues.

The following edits to the code should be done so as to handle these additional requirements:
1. There should be no spaces in any line that contains the #include. This is specific to "c" file.
2. If there is a line that starts with the syntax: datatype+name+(), it should be followed by a space followed by "{" on the same line and nothing more should be on this line
3. The next line should have to start with 4 spaces and the code should be written based on all the requirements as present in code.
4. All lines under this line should have 4 spaces intendation present.
5. Please note that such examples need to be handled by the code: in the if-else and ladder or nested statements, we need to check indentation where for example:
if (test_expression1) {
    // Statements
} else {
    // Statements
}

in case of if- else if - else ladder scenario
if (test_expression1) {
    // Statements
} else if (test_expression2) {
    // Statements
} else if (test_expression3) {
    // Statements
} else {
    // Statements
}

in case of nested if-else:
if (condition1) {
    // Executes when condition1 is true
    if (condition2) {
        // Executes when condition2 is true
    } else {
        // Executes when condition2 is false
    }
} else {
    // Executes when condition1 is false
}


Lines reviewed:
int main() {
    printf("hello world");
    return 0;

This is corresponding to line 3 and 5 is has the correct syntax of 4 spaces and ends with ;

Indentation issue at line 2: Incorrect indentation.
Indentation issue at line 3: Incorrect indentation.
Indentation issue at line 4: Incorrect indentation.
Whitespace issue at line 3: Excessive whitespace within line.
Whitespace issue at line 4: Excessive whitespace within line.

    def check_indentation(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                inside_function = False
                indentation_level = 0

                for line_number, line in enumerate(lines, start=1):
                    # Skip empty lines and user comments
                    if not line.strip() or line.strip().startswith("//") or line.strip().startswith("/*"):
                        continue

                    # Check #include lines
                    if line.strip().startswith("#include"):
                        # Check for correct syntax after #include
                        if not re.match(r'^#include\s+<\w+\.h>\s*$', line.strip()):
                            print(f"Syntax issue at line {line_number}: Incorrect syntax after #include.")
                        continue  # Skip further checks for #include lines

                    # Check for global variables
                    if ";" in line and not inside_function:
                        if line.strip().endswith(";"):
                            print(f"Indentation issue at line {line_number}: Incorrect indentation for global variable declaration.")

                    # Check for function definitions
                    if "{" in line and "(" in line:
                        inside_function = True
                        if line.strip().endswith("{"):
                            indentation_level += 1

                    if inside_function:
                        # Check control structures indentation
                        control_structures = ["for", "while", "do", "if", "else", "elif", "elseif", "unless"]
                        for control_structure in control_structures:
                            if control_structure in line.strip():
                                if not line.strip().startswith(" " * 4 * (indentation_level + 1)):
                                    print(f"Indentation issue at line {line_number}: Incorrect indentation for {control_structure} statement.")
                        if "}" in line:
                            indentation_level -= 1
                            if indentation_level == 0:
                                inside_function = False
                                continue

                    # Check indentation of non-empty, non-comment lines
                    if not line.strip().startswith(" " * 4):
                        print(f"Indentation issue at line {line_number}: Incorrect indentation.")
                    
        except FileNotFoundError:
            print(f"File not found: {self.script_path}")
        except Exception as e:
            print(f"Error during indentation check: {str(e)}")


	def check_indentation(self):
		try:
			with open(self.script_path, "r") as script_file:
				lines = script_file.readlines()

				inside_function = False
				indentation_level = 0

				for line_number, line in enumerate(lines, start=1):
					# Skip empty lines and user comments
					if not line.strip() or line.strip().startswith("//") or line.strip().startswith("/*"):
						continue

					# Check #include lines
					if line.strip().startswith("#include"):
						# Check for correct syntax after #include
						if not re.match(r'^#include\s+<\w+\.h>\s*$', line.strip()):
							print(f"Syntax issue at line {line_number}: Incorrect syntax after #include.")
						continue  # Skip further checks for #include lines

					# Check for global variables
					if ";" in line and not inside_function:
						if line.strip().endswith(";"):
							print(f"Indentation issue at line {line_number}: Incorrect indentation for global variable declaration.")

					# Check for function definitions
					if "{" in line and "(" in line:
						inside_function = True
						if line.strip().endswith("{"):
							indentation_level += 1

					if inside_function:
						# Check control structures indentation
						control_structures = ["for", "while", "do", "if", "else", "elif", "elseif", "unless"]
						for control_structure in control_structures:
							if control_structure in line.strip():
								if not line.strip().startswith(" " * 4 * (indentation_level + 1)):
									print(f"Indentation issue at line {line_number}: Incorrect indentation for {control_structure} statement.")
						if "}" in line:
							indentation_level -= 1
							if indentation_level == 0:
								inside_function = False
								continue

					# Check indentation of non-empty, non-comment lines
					if not line.strip().startswith(" " * 4 * indentation_level):
						print(f"Indentation issue at line {line_number}: Incorrect indentation.")

		except FileNotFoundError:
			print(f"File not found: {self.script_path}")
		except Exception as e:
			print(f"Error during indentation check: {str(e)}")
			
			
---------------------------------------------------------------------------------------------------------------------------------------------

Additional Requirements:

This script works well. I have an additional requirement that i am trying to implement.
I am trying to create a log, basically a text file logging all details of the run. My intention is to write the output data into a text file and save it in the same location from where the original input script was read from in the beginning

Append the logs to an email.
			
---------------------------------------------------------------------------------------------------------------------------------------------

Allot Requirements:
All symbols should have a prefix which identifies their module.
Variables/functions start with lower-case.
Types/classes start with upper-case.
Constants are all upper-case.
Global variables start with 'g_'.
Members start with 'm_'
Pointers start with 'p'.

--
when a person says the requirement in the .cpp scripts is to have:
All the symbols should have a prefix which identifies their module.
What is a possible logic to have a check for this?

What is a module: Expected Formats in cpp and c files
export module ModuleName; - This declares and exports a module named ModuleName.
export declaration; - This exports a declaration (like a function, variable, or type) from the current module.
import ModuleName; - This imports a module named ModuleName into the current module or program.
module ModuleName:PartitionName; - This declares a module partition named PartitionName in the module ModuleName.
--
when a person says the requirement in the .cpp scripts is to have:
Variables/functions names start with lower-case.
What is a possible logic to have a check for this?


--
when a person says the requirement in the .cpp scripts is to have:
Types/classes start with upper-case.
What is a possible logic to have a check for this?
--
when a person says the requirement in the .cpp scripts is to have:
Constants are all upper-case.
What is a possible logic to have a check for this?
--
when a person says the requirement in the .cpp scripts is to have:
Global variables start with 'g_'.
What is a possible logic to have a check for this?
--
when a person says the requirement in the .cpp scripts is to have:
Members start with 'm_'
What is a possible logic to have a check for this?
--
when a person says the requirement in the .cpp scripts is to have:
Pointers start with 'p'.
What is a possible logic to have a check for this?


*****************************************************************************************************************************************
*****************************************************************************************************************************************
*****************************************************************************************************************************************

Present Code:

import re
import logging
from pathlib import Path
from datetime import datetime
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders

class ScriptAnalyzer:
    def __init__(self, script_path):
        self.script_path = Path(script_path)
        self.log_file = self.get_log_file_name()
        logging.basicConfig(filename=self.log_file, level=logging.INFO,
                            format='%(asctime)s - %(levelname)s - %(message)s')

    def get_log_file_name(self):
        current_datetime = datetime.now().strftime("%H-%M-%S-on-%d-%m-%Y")
        log_folder = self.script_path.parent / "Logs"
        log_folder.mkdir(parents=True, exist_ok=True)  # Create Logs folder if it doesn't exist
        log_file_name = f"Logs-{self.script_path.stem}-at-{current_datetime}.log"
        return log_folder / log_file_name

    def run_analysis(self):
        try:
            # Check script indentation
            self.check_indentation()

            # Check naming conventions
            self.check_naming_conventions()

            # Check modularization
            self.check_modularization()

            # Check file encoding
            self.check_file_encoding()

            # Check consistency
            self.check_consistency()

            # Check code reuse
            self.check_code_reuse()

            # Check performance considerations
            self.check_performance()

            # Check whitespace usage
            self.check_whitespace()

            # Check memory leakages (for C scripts)
            if str(self.script_path).endswith(".c"):
                self.check_memory_leaks()
            elif str(self.script_path).endswith(".pl"):
                self.check_perl_specific_checks()
            
            # Print summary of the analysis results
            print("Script analysis completed successfully.")
            # Creating Log with Analysis in Log Directory    
            logging.info("Script analysis completed successfully.")
            
            # Email the log file
            sender_email = 'vaishnavi.m@thinkpalm.com'
            sender_password = 'Malu$123'
            recipient_email = 'manu.m@thinkpalm.com'
            attachment_path = self.log_file
            send_email(sender_email, sender_password, recipient_email, attachment_path)
            
        except Exception as e:
            logging.error(f"Error during analysis: {str(e)}")


    def check_indentation(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                inside_function = False
                indentation_level = 0

                for line_number, line in enumerate(lines, start=1):
                    # Skip empty lines and user comments
                    if not line.strip() or line.strip().startswith("//") or line.strip().startswith("/*"):
                        continue

                    # Check for TAB space usage
                    if "\t" in line:
                        logging.warning(f"Indentation issue at line {line_number}: TAB space used. Convert TABs to spaces.")

                    # Check #include lines
                    if line.strip().startswith("#include"):
                        # Check for correct syntax after #include
                        if not re.match(r'^#include\s+<\w+\.h>\s*$', line.strip()):
                            logging.warning(f"Syntax issue at line {line_number}: Incorrect syntax after #include.")
                        continue  # Skip further checks for #include lines

                    # Check for function definitions
                    if "{" in line and "(" in line and not inside_function:
                        if line.strip().endswith("{"):
                            inside_function = True
                            indentation_level += 1
                            continue  # Skip further checks for function definition lines

                    if inside_function:
                        # Check control structures indentation
                        control_structures = ["for", "while", "do", "if", "else", "elif", "elseif", "unless"]
                        for control_structure in control_structures:
                            if control_structure in line.strip():
                                if not line.startswith(" " * 4 * indentation_level):
                                    logging.warning(f"Indentation issue at line {line_number}: Incorrect indentation for {control_structure} statement.")
                                if line.strip().endswith("{"):
                                    indentation_level += 1
                            if "}" in line:
                                indentation_level -= 1
                                if indentation_level == 0:
                                    inside_function = False
                                    continue

                    # Check indentation of non-empty, non-comment lines
                    if not line.startswith(" " * 4 * indentation_level):
                        logging.warning(f"Indentation issue at line {line_number}: Incorrect indentation.")

        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during indentation check: {str(e)}")


    def check_naming_conventions(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

            for line_number, line in enumerate(lines, start=1):
                # Remove leading/trailing whitespaces
                stripped_line = line.strip()

                # Check naming conventions based on file extension
                if str(self.script_path).endswith((".c", ".pl")):
                    self.check_common_naming_conventions(stripped_line, line_number)

        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during naming conventions check: {str(e)}")


    def check_common_naming_conventions(self, line, line_number):
        # Implement common naming conventions checks
        # Example: Check if variable names follow a consistent pattern
        if str(self.script_path).endswith(".c"):
            # Check for C-specific naming conventions
            if re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', line):
                logging.warning(f"Naming convention issue at line {line_number}: {line}")
        elif str(self.script_path).endswith(".pl"):
            # Check for Perl-specific naming conventions
            if re.match(r'^[a-zA-Z][a-zA-Z0-9]*$', line):
                logging.warning(f"Naming convention issue at line {line_number}: {line}")


    def check_modularization(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

            if str(self.script_path).endswith(".c"):
                num_functions = 0
                for line in lines:
                    # Exclude the main function from the count
                    if re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*\s*\(\s*\)\s*\{', line) and "main" not in line:
                        num_functions += 1

                # if num_functions < 3:
                #     logging.warning(f"Modularization issue: The file {self.script_path} should have at least 3 functions.")

            elif str(self.script_path).endswith(".pl"):
                num_subroutines = 0
                for line in lines:
                    if re.match(r'^\s*sub\s', line):
                        num_subroutines += 1

                # if num_subroutines < 3:
                #     logging.warning(f"Modularization issue: The file {self.script_path} should have at least 3 subroutines.")

        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during modularization check: {str(e)}")

                
    def check_file_encoding(self):
        try:
            with open(self.script_path, "rb") as script_file:
                script_file.read().decode('utf-8')
        except UnicodeDecodeError as e:
            logging.error(f"File encoding issue: {str(e)} at {self.script_path}")


    def check_consistency(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                # Check for consistent line endings (e.g., only '\n', '\r\n', or '\r')
                for line_number, line in enumerate(lines[:-1], start=1):
                    if not line.endswith(('\n', '\r\n', '\r')):
                        logging.warning(f"Consistency issue at line {line_number}: Inconsistent line ending.")

                # Check the last line for correct syntax
                last_line = lines[-1].strip()
                if last_line != "}":
                    logging.warning(f"Consistency issue: Incorrect syntax at the end of the file. Expected '}}', found '{last_line}'.")

        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during consistency check: {str(e)}")


    def check_code_reuse(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                for line_number, line in enumerate(lines, start=1):
                    # Check for code reuse patterns
                    if re.match(r'^\s*(import|require)\s+', line):
                        logging.warning(f"Code reuse issue at line {line_number}: Possible code duplication.")
        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during code reuse check: {str(e)}")


    def check_performance(self):
        try:
            # Placeholder for performance checks
            pass
        except Exception as e:
            logging.error(f"Error during performance check: {str(e)}")


    def check_whitespace(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                for line_number, line in enumerate(lines, start=1):
                    # Check for excessive whitespace within lines
                    if not line.strip().startswith("#include"):
                        stripped_line = line.strip()  # strip leading and trailing spaces
                        if '  ' in stripped_line:  # check for two or more consecutive spaces
                            logging.warning(f"Whitespace issue at line {line_number}: Excessive whitespace within line.")
                        if line.rstrip('\n').endswith(' '):  # check if line ends with a space
                            logging.warning(f"Whitespace issue at line {line_number}: Line ends with a space.")
        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during whitespace check: {str(e)}")


    def check_memory_leaks(self):
        try:
            # Placeholder for memory leak checks
            pass
        except Exception as e:
            logging.error(f"Error during memory leak check: {str(e)}")


    def check_perl_specific_checks(self):
        try:
            # Placeholder for Perl-specific checks
            pass
        except Exception as e:
            logging.error(f"Error during Perl-specific check: {str(e)}")


def send_email(sender_email, sender_password, recipient_email, attachment_path):
    smtp_server = 'smtp-mail.outlook.com'
    smtp_port = 587

    # Create a multipart message
    message = MIMEMultipart()
    message['From'] = sender_email
    message['To'] = recipient_email

    # Get the current date and format it as desired
    current_date = datetime.now().strftime('%Y-%m-%d')
    subject = f'Script Analyzer - {current_date}'  # Add current date to the subject
    message['Subject'] = subject

    # Add body text
    body = 'Please find the attached file.'
    message.attach(MIMEText(body, 'plain'))

    # Add attachment
    if attachment_path:
        attachment_filename = attachment_path.name
        attachment = open(attachment_path, "rb")
        part = MIMEBase('application', 'octet-stream')
        part.set_payload(attachment.read())
        encoders.encode_base64(part)
        part.add_header('Content-Disposition', f"attachment; filename= {attachment_filename}")
        message.attach(part)
        attachment.close()  # Close the file after reading

    # Connect to the SMTP server and send the email
    try:
        server = smtplib.SMTP(smtp_server, smtp_port)
        server.starttls()
        server.login(sender_email, sender_password)
        server.sendmail(sender_email, recipient_email, message.as_string())
        server.quit()
        print("Email sent successfully!")
        
    except smtplib.SMTPException as e:
        print(f"Failed to send email: {e}")
    except Exception as e:
        print(f"Unexpected error: {e}")

if __name__ == "__main__":
    script_path = input("Enter the Full Path to the Access the Script that needs to be Reviewed (Supports -> C (*.c) CPP (*.cpp) or Perl (*.pl or *.pm)): ")
    analyzer = ScriptAnalyzer(script_path)
    analyzer.run_analysis()
	
______________________________________________________________________________________________________________________________________________________________

The Code to work on:import re
import logging
import subprocess
import platform
import smtplib
from pathlib import Path
from datetime import datetime
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
from pycparser import c_ast, parse_file

class ScriptAnalyzer:
    def __init__(self, script_path):
        self.script_path = Path(script_path)
        self.log_file = self.get_log_file_name()
        logging.basicConfig(filename=self.log_file, level=logging.INFO,
                            format='%(asctime)s - %(levelname)s - %(message)s')

    def get_log_file_name(self):
        current_datetime = datetime.now().strftime("%H-%M-%S-on-%d-%m-%Y")
        log_folder = self.script_path.parent / "Logs"
        log_folder.mkdir(parents=True, exist_ok=True)  # Create Logs folder if it doesn't exist
        log_file_name = f"Logs-{self.script_path.stem}-at-{current_datetime}.log"
        return log_folder / log_file_name

    def run_analysis(self):
        try:
            # Check script indentation
            self.check_indentation()

            # Check naming conventions
            self.check_naming_conventions()

            # Check modularization
            self.check_modularization()

            # Check file encoding
            self.check_file_encoding()

            # Check consistency
            self.check_consistency()

            # Check code reuse
            self.check_code_reuse()

            # Check performance considerations
            self.check_performance()

            # Check whitespace usage
            self.check_whitespace()

            # # Check memory leakages (for C scripts)
            # if str(self.script_path).endswith(".cpp"):
            #     self.check_memory_leaks()
            # elif str(self.script_path).endswith(".pl"):
            #     self.check_perl_specific_checks()
            
            # Print summary of the analysis results
            print("Script Analysis completed.")
            # Creating Log with Analysis in Log Directory    
            logging.info("Script Analysis completed.")
            
            # Email the log file
            sender_email = 'vaishnavi.m@thinkpalm.com'
            sender_password = 'Malu$123'
            recipient_email = 'manu.m@thinkpalm.com'
            attachment_path = self.log_file
            send_email(sender_email, sender_password, recipient_email, attachment_path)
            
        except Exception as e:
            logging.error(f"Error during analysis: {str(e)}")


    def check_indentation(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                inside_function = False
                indentation_level = 0

                for line_number, line in enumerate(lines, start=1):
                    # Skip empty lines and user comments
                    if not line.strip() or line.strip().startswith("//") or line.strip().startswith("/*"):
                        continue

                    # Check for TAB space usage
                    if "\t" in line:
                        logging.warning(f"Indentation issue at line {line_number}: TAB space used. Convert TABs to spaces.")

                    # Check #include lines
                    if line.strip().startswith("#include"):
                        # Check for correct syntax after #include
                        if not re.match(r'^#include\s+(<\w+\.h>|"\w+\.h")\s*$', line.strip()):
                            logging.warning(f"Syntax issue at line {line_number}: Incorrect syntax after #include.")
                        continue  # Skip further checks for #include lines

                    # Check for function definitions
                    if "{" in line and "(" in line and not inside_function:
                        if line.strip().endswith("{"):
                            inside_function = True
                            indentation_level += 1
                            continue  # Skip further checks for function definition lines

                    if inside_function:
                        # Check control structures indentation
                        control_structures = ["for", "while", "do", "if", "else", "elif", "elseif", "unless"]
                        for control_structure in control_structures:
                            if control_structure in line.strip():
                                if not line.startswith(" " * 4 * indentation_level):
                                    logging.warning(f"Indentation issue at line {line_number}: Incorrect indentation for {control_structure} statement.")
                                if line.strip().endswith("{"):
                                    indentation_level += 1
                            if "}" in line:
                                indentation_level -= 1
                                if indentation_level == 0:
                                    inside_function = False
                                    continue

                    # Check indentation of non-empty, non-comment lines
                    if not line.startswith(" " * 4 * indentation_level):
                        logging.warning(f"Indentation issue at line {line_number}: Incorrect indentation.")

        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during indentation check: {str(e)}")


	def check_naming_conventions(self):
		try:
			# Load the C file
			ast = parse_file(str(self.script_path), use_cpp=True)
	
			# This is a visitor class that checks naming conventions
			class NamingConventionVisitor(c_ast.NodeVisitor):
				def __init__(self):
					self.module_prefix = None
	
				def visit_FileAST(self, node):
					if node.ext:
						for ext in node.ext:
							if isinstance(ext, c_ast.Decl):
								if ext.name and ext.name.startswith('MODULE_'):
									self.module_prefix = ext.name
					self.generic_visit(node)
	
				def visit_FuncDef(self, node):
					if not node.decl.name[0].islower():
						logging.warning(f"Function {node.decl.name} does not start with a lowercase letter")
					self.visit(node.body)
	
				def visit_Decl(self, node):
					if isinstance(node.type, c_ast.TypeDecl):
						if node.name.islower():
							logging.warning(f"Variable {node.name} does not start with an uppercase letter")
						elif node.name.upper() == node.name:
							logging.warning(f"Constant {node.name} should not be all uppercase")
						elif self.module_prefix and not node.name.startswith(self.module_prefix):
							logging.warning(f"Symbol {node.name} should have a prefix '{self.module_prefix}'")
					elif isinstance(node.type, c_ast.PtrDecl):
						if not node.name.startswith('p_'):
							logging.warning(f"Pointer variable {node.name} should start with 'p_'")
					elif isinstance(node.type, c_ast.Struct):
						if not node.name[0].isupper():
							logging.warning(f"Type/Class {node.name} does not start with an uppercase letter")
					self.generic_visit(node)
	
			# Visit each node in the AST
			v = NamingConventionVisitor()
			v.visit(ast)
	
		except FileNotFoundError:
			logging.error(f"File not found: {self.script_path}")
		except Exception as e:
			logging.error(f"Error during naming conventions check: {str(e)}")
	


    def check_modularization(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

            if str(self.script_path).endswith(".cpp"):
                num_functions = 0
                for line in lines:
                    # Exclude the main function from the count
                    if re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*\s*\(\s*\)\s*\{', line) and "main" not in line:
                        num_functions += 1

                # if num_functions < 3:
                #     logging.warning(f"Modularization issue: The file {self.script_path} should have at least 3 functions.")

            elif str(self.script_path).endswith(".pl"):
                num_subroutines = 0
                for line in lines:
                    if re.match(r'^\s*sub\s', line):
                        num_subroutines += 1

                # if num_subroutines < 3:
                #     logging.warning(f"Modularization issue: The file {self.script_path} should have at least 3 subroutines.")

        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during modularization check: {str(e)}")

                
    def check_file_encoding(self):
        try:
            with open(self.script_path, "rb") as script_file:
                script_file.read().decode('utf-8')
        except UnicodeDecodeError as e:
            logging.error(f"File encoding issue: {str(e)} at {self.script_path}")


    def check_consistency(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                # Check for consistent line endings (e.g., only '\n', '\r\n', or '\r')
                for line_number, line in enumerate(lines[:-1], start=1):
                    if not line.endswith(('\n', '\r\n', '\r')):
                        logging.warning(f"Consistency issue at line {line_number}: Inconsistent line ending.")

                # Check the last line for correct syntax
                last_line = lines[-1].strip()
                if last_line != "}":
                    logging.warning(f"Consistency issue: Incorrect syntax at the end of the file. Expected '}}', found '{last_line}'.")

        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during consistency check: {str(e)}")


    def check_code_reuse(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                for line_number, line in enumerate(lines, start=1):
                    # Check for code reuse patterns
                    if re.match(r'^\s*(import|require)\s+', line):
                        logging.warning(f"Code reuse issue at line {line_number}: Possible code duplication.")
        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during code reuse check: {str(e)}")


    def check_performance(self):
        try:
            # Placeholder for performance checks
            pass
        except Exception as e:
            logging.error(f"Error during performance check: {str(e)}")


    def check_whitespace(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                for line_number, line in enumerate(lines, start=1):
                    # Skip empty lines and user comments
                    if not line.strip() or line.strip().startswith("//") or line.strip().startswith("/*"):
                        continue

                    # Check for excessive whitespace within lines
                    stripped_line = line.strip()  # strip leading and trailing spaces
                    if '  ' in stripped_line:  # check for two or more consecutive spaces
                        logging.warning(f"Whitespace issue at line {line_number}: Excessive whitespace within line.")
                    if line.rstrip('\n').endswith(' '):  # check if line ends with a space
                        logging.warning(f"Whitespace issue at line {line_number}: Line ends with a space.")
        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during whitespace check: {str(e)}")


    def check_memory_leaks(self):
        try:
            cpp_file = str(self.script_path)
            executable_name = cpp_file.replace('.cpp', '.exe') if platform.system() == 'Windows' else cpp_file.replace('.cpp', '')

            if platform.system() == 'Windows':
                subprocess.check_call(['g++', cpp_file, '-o', executable_name])
                subprocess.check_call(['drmemory', '-logdir', 'logs', executable_name])
            else:
                subprocess.check_call(['g++', cpp_file, '-o', executable_name])
                valgrind_output = subprocess.check_output(['valgrind', '--leak-check=full', executable_name])
                if 'no leaks are possible' not in valgrind_output.decode('utf-8'):
                    logging.warning("Memory leak detected!")

        except subprocess.CalledProcessError as e:
            logging.error(f"Error running memory leak check: {e}")
        except FileNotFoundError:
            logging.error("Memory leak check tool not found. Please install the required tool.")
        except Exception as e:
            logging.error(f"Error checking memory leaks: {str(e)}")


    def check_perl_specific_checks(self):
        try:
            # Placeholder for Perl-specific checks
            pass
        except Exception as e:
            logging.error(f"Error during Perl-specific check: {str(e)}")


def send_email(sender_email, sender_password, recipient_email, attachment_path):
    smtp_server = 'smtp-mail.outlook.com'
    smtp_port = 587

    # Create a multipart message
    message = MIMEMultipart()
    message['From'] = sender_email
    message['To'] = recipient_email

    # Get the current date and format it as desired
    current_date = datetime.now().strftime('%Y-%m-%d')
    subject = f'Script Analyzer - {current_date}'  # Add current date to the subject
    message['Subject'] = subject

    # Add body text
    body = 'Please find the attached file.'
    message.attach(MIMEText(body, 'plain'))

    # Add attachment
    if attachment_path:
        attachment_filename = attachment_path.name
        attachment = open(attachment_path, "rb")
        part = MIMEBase('application', 'octet-stream')
        part.set_payload(attachment.read())
        encoders.encode_base64(part)
        part.add_header('Content-Disposition', f"attachment; filename= {attachment_filename}")
        message.attach(part)
        attachment.close()  # Close the file after reading

    # Connect to the SMTP server and send the email
    try:
        server = smtplib.SMTP(smtp_server, smtp_port)
        server.starttls()
        server.login(sender_email, sender_password)
        server.sendmail(sender_email, recipient_email, message.as_string())
        server.quit()
        print("Email sent successfully!")

    except (smtplib.SMTPException, IOError, OSError, Exception) as e:
        if isinstance(e, smtplib.SMTPException):
            print(f"Failed to send email: {e}")
        elif isinstance(e, IOError):
            print(f"I/O error occurred: {e}")
        elif isinstance(e, OSError):
            print(f"OS error occurred: {e}")
        else:
            print(f"Unexpected error: {e}")
        logging.error(f"Error occurred while sending email: {e}")


if __name__ == "__main__":
    script_path = input("Enter the Full Path to the Access the Script that needs to be Reviewed (Supports -> C (*.c) CPP (*.cpp) or Perl (*.pl or *.pm)): ")
    analyzer = ScriptAnalyzer(script_path)
    analyzer.run_analysis()


Additional Requirements:
have all the below requirements for verifications been addressed in the code mentioned??
The input C++ file must have
--> All symbols should have a prefix which identifies their module.
--> Variables/functions start with lower-case.
--> Types/classes start with upper-case.
--> Constants are all upper-case.
--> Global variables start with 'g_'.
--> Members start with 'm_'
--> All Pointer Variables start with 'p'.

Please let me know where and how this is implemented in the lines of code to handle these enhancements

-------------------------------------------------------------------------------------------------------------------

import re
import logging
import subprocess
import platform
import smtplib
from pathlib import Path
from datetime import datetime
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
from pycparser import c_ast, parse_file

# Set global indentation and iteration values
INDENTATION_SPACES = 4
ITERATION_VALUES = {
    'MAX_FUNCTION_COUNT': 3,
    'MAX_SUBROUTINE_COUNT': 3
}

class ScriptAnalyzer:
    def __init__(self, script_path):
        self.script_path = Path(script_path)
        self.log_file = self.get_log_file_name()
        logging.basicConfig(filename=self.log_file, level=logging.INFO,
                            format='%(asctime)s - %(levelname)s - %(message)s')
        self.sender_email = 'vaishnavi.m@thinkpalm.com'
        self.sender_password = 'Malu$123'
        self.recipient_email = 'manu.m@thinkpalm.com'

    def get_log_file_name(self):
        current_datetime = datetime.now().strftime("%H-%M-%S-on-%d-%m-%Y")
        log_folder = self.script_path.parent / "Logs"
        log_folder.mkdir(parents=True, exist_ok=True)  # Create Logs folder if it doesn't exist
        log_file_name = f"Logs-{self.script_path.stem}-at-{current_datetime}.log"
        return log_folder / log_file_name

    def run_analysis(self):
        try:
            # Check script indentation
            self.check_indentation()

            # Check naming conventions
            self.check_naming_conventions()

            # Check modularization
            self.check_modularization()

            # Check file encoding
            self.check_file_encoding()

            # Check consistency
            self.check_consistency()

            # Check code reuse
            self.check_code_reuse()

            # Check whitespace usage
            self.check_whitespace()

            # Print summary of the analysis results
            print("Script Analysis completed.")
            # Creating Log with Analysis in Log Directory
            logging.info("Script Analysis completed.")

            # Email the log file
            attachment_path = self.log_file
            self.send_email(attachment_path)

        except Exception as e:
            logging.error(f"Error during analysis: {str(e)}")

    def check_indentation(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                inside_function = False
                indentation_level = 0

                for line_number, line in enumerate(lines, start=1):
                    # Skip empty lines and user comments
                    if not line.strip() or line.strip().startswith("//") or line.strip().startswith("/*"):
                        continue

                    # Check for TAB space usage
                    if "\t" in line:
                        logging.warning(f"Indentation issue at line {line_number}: TAB space used. Convert TABs to spaces.")

                    # Check #include lines
                    if line.strip().startswith("#include"):
                        # Check for correct syntax after #include
                        if not re.match(r'^#include\s+(<\S+\.h>|"\S+\.h")\s*$', line.strip()):
                            logging.warning(f"Syntax issue at line {line_number}: Incorrect syntax after #include.")
                        continue  # Skip further checks for #include lines

                    # Check for function definitions
                    if "{" in line and "(" in line and not inside_function:
                        if line.strip().endswith("{"):
                            inside_function = True
                            indentation_level += 1
                            continue  # Skip further checks for function definition lines

                    if inside_function:
                        # Check control structures indentation
                        control_structures = ["for", "while", "do", "if", "else", "elif", "elseif", "unless"]
                        for control_structure in control_structures:
                            if control_structure in line.strip():
                                if not line.startswith(" " * INDENTATION_SPACES * indentation_level):
                                    logging.warning(f"Indentation issue at line {line_number}: Incorrect indentation for {control_structure} statement.")
                                if line.strip().endswith("{"):
                                    indentation_level += 1
                            if "}" in line:
                                indentation_level -= 1
                                if indentation_level == 0:
                                    inside_function = False
                                    continue

                    # Check indentation of non-empty, non-comment lines
                    if not line.startswith(" " * INDENTATION_SPACES * indentation_level):
                        logging.warning(f"Indentation issue at line {line_number}: Incorrect indentation.")

        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during indentation check: {str(e)}")

    def check_naming_conventions(self):
        try:
            # Load the C file
            ast = parse_file(str(self.script_path))

            # This is a visitor class that checks naming conventions
            class NamingConventionVisitor(c_ast.NodeVisitor):
                def __init__(self):
                    self.module_prefix = None

                def visit_FileAST(self, node):
                    if node.ext:
                        for ext in node.ext:
                            if isinstance(ext, c_ast.Decl):
                                if ext.name and ext.name.startswith('MODULE_'):
                                    self.module_prefix = ext.name
                    self.generic_visit(node)

                def visit_FuncDef(self, node):
                    if not node.decl.name[0].islower():
                        logging.warning(f"Function {node.decl.name} does not start with a lowercase letter")
                    self.visit(node.body)

                def visit_Decl(self, node):
                    if isinstance(node.type, c_ast.TypeDecl):
                        if node.name.islower():
                            logging.warning(f"Variable {node.name} does not start with an uppercase letter")
                        elif node.name.upper() == node.name:
                            logging.warning(f"Constant {node.name} should not be all uppercase")
                        elif self.module_prefix and not node.name.startswith(self.module_prefix):
                            logging.warning(f"Symbol {node.name} should have a prefix '{self.module_prefix}'")
                    elif isinstance(node.type, c_ast.PtrDecl):
                        if not node.name.startswith('p_'):
                            logging.warning(f"Pointer variable {node.name} should start with 'p_'")
                    elif isinstance(node.type, c_ast.Struct):
                        if not node.name[0].isupper():
                            logging.warning(f"Type/Class {node.name} does not start with an uppercase letter")
                    self.generic_visit(node)

            # Visit each node in the AST
            v = NamingConventionVisitor()
            v.visit(ast)

        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during naming conventions check: {str(e)}")

    def check_modularization(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

            num_functions = 0
            for line in lines:
                # Exclude the main function from the count
                if re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*\s*\(\s*\)\s*\{', line) and "main" not in line:
                    num_functions += 1

            if num_functions < ITERATION_VALUES['MAX_FUNCTION_COUNT']:
                logging.warning(f"Modularization issue: The file {self.script_path} should have at least {ITERATION_VALUES['MAX_FUNCTION_COUNT']} functions.")

        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during modularization check: {str(e)}")

    def check_file_encoding(self):
        try:
            with open(self.script_path, "rb") as script_file:
                script_file.read().decode('utf-8')
        except UnicodeDecodeError as e:
            logging.error(f"File encoding issue: {str(e)} at {self.script_path}")

    def check_consistency(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                # Check for consistent line endings (e.g., only '\n', '\r\n', or '\r')
                for line_number, line in enumerate(lines[:-1], start=1):
                    if not line.endswith(('\n', '\r\n', '\r')):
                        logging.warning(f"Consistency issue at line {line_number}: Inconsistent line ending.")

                # Check the last line for correct syntax
                last_line = lines[-1].strip()
                if last_line != "}":
                    logging.warning(f"Consistency issue: Incorrect syntax at the end of the file. Expected '}}', found '{last_line}'.")

        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during consistency check: {str(e)}")

    def check_code_reuse(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                for line_number, line in enumerate(lines, start=1):
                    # Check for code reuse patterns
                    if re.match(r'^\s*(import|require)\s+', line):
                        logging.warning(f"Code reuse issue at line {line_number}: Possible code duplication.")
        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during code reuse check: {str(e)}")

    def check_whitespace(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                for line_number, line in enumerate(lines, start=1):
                    # Skip empty lines and user comments
                    if not line.strip() or line.strip().startswith("//") or line.strip().startswith("/*"):
                        continue

                    # Check for excessive whitespace within lines
                    stripped_line = line.strip()  # strip leading and trailing spaces
                    if '  ' in stripped_line:  # check for two or more consecutive spaces
                        logging.warning(f"Whitespace issue at line {line_number}: Excessive whitespace within line.")
                    if line.rstrip('\n').endswith(' '):  # check if line ends with a space
                        logging.warning(f"Whitespace issue at line {line_number}: Line ends with a space.")
        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during whitespace check: {str(e)}")

    def check_memory_leaks(self):
        try:
            cpp_file = str(self.script_path)
            executable_name = cpp_file.replace('.cpp', '.exe') if platform.system() == 'Windows' else cpp_file.replace('.cpp', '')

            if platform.system() == 'Windows':
                subprocess.check_call(['g++', cpp_file, '-o', executable_name])
                subprocess.check_call(['drmemory', '-logdir', 'logs', executable_name])
            else:
                subprocess.check_call(['g++', cpp_file, '-o', executable_name])
                valgrind_output = subprocess.check_output(['valgrind', '--leak-check=full', executable_name])
                if 'no leaks are possible' not in valgrind_output.decode('utf-8'):
                    logging.warning("Memory leak detected!")

        except subprocess.CalledProcessError as e:
            logging.error(f"Error running memory leak check: {e}")
        except FileNotFoundError:
            logging.error("Memory leak check tool not found. Please install the required tool.")
        except Exception as e:
            logging.error(f"Error checking memory leaks: {str(e)}")

    def send_email(self, attachment_path):
        smtp_server = 'smtp-mail.outlook.com'
        smtp_port = 587

        # Create a multipart message
        message = MIMEMultipart()
        message['From'] = self.sender_email
        message['To'] = self.recipient_email

        # Get the current date and format it as desired
        current_date = datetime.now().strftime('%Y-%m-%d')
        subject = f'Script Analyzer - {current_date}'  # Add current date to the subject
        message['Subject'] = subject

        # Add body text
        body = 'Please find the attached file.'
        message.attach(MIMEText(body, 'plain'))

        # Add attachment
        if attachment_path:
            attachment_filename = attachment_path.name
            attachment = open(attachment_path, "rb")
            part = MIMEBase('application', 'octet-stream')
            part.set_payload(attachment.read())
            encoders.encode_base64(part)
            part.add_header('Content-Disposition', f"attachment; filename= {attachment_filename}")
            message.attach(part)
            attachment.close()  # Close the file after reading

        # Connect to the SMTP server and send the email
        try:
            server = smtplib.SMTP(smtp_server, smtp_port)
            server.starttls()
            server.login(self.sender_email, self.sender_password)
            server.sendmail(self.sender_email, self.recipient_email, message.as_string())
            server.quit()
            print("Email sent successfully!")

        except (smtplib.SMTPException, IOError, OSError) as e:
            logging.error(f"Failed to send email: {str(e)}")

# Sample usage
if __name__ == "__main__":
    analyzer = ScriptAnalyzer("example.cpp")
    analyzer.run_analysis()


Lets check the following, 
//Check line by line and verify if any hardcoded values, however minute or foolish --> Globally assign these values to variables so any person who comes looks at it can edit just the values to suit their requirement.

--------------------------------------------------------------------------------------------------------------

Updated and Code ready ---> Next Stage -> User to Access code via CI or GUI

User
let me provide the finalized code for this moment:

import re
import os
import logging
import subprocess
import smtplib
import platform
from pathlib import Path
from datetime import datetime
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
from pycparser import c_ast, parse_file

# Set global configuration values
SENDER_EMAIL = 'vaishnavi.m@thinkpalm.com'
SENDER_PASSWORD = 'Malu$123'
RECIPIENT_EMAIL = 'manu.m@thinkpalm.com'
SMTP_SERVER = 'smtp-mail.outlook.com'
SMTP_PORT = 587

# Set global indentation, line count and iteration values
INDENTATION_SPACES = 4
EXPECTED_LINE_COUNT = 2000
ITERATION_VALUES = {
    'MAX_FUNCTION_COUNT': 3,  # Maximum number of functions expected in the script
    'MAX_SUBROUTINE_COUNT': 3  # Maximum number of subroutines expected in the script
}

class ScriptAnalyzer:
    def __init__(self, script_path):
        self.script_path = Path(script_path)
        self.log_file = self.get_log_file_name()
        logging.basicConfig(filename=self.log_file, level=logging.INFO,
                            format='%(asctime)s - %(levelname)s - %(message)s')

    def get_log_file_name(self):
        current_datetime = datetime.now().strftime("%H-%M-%S-on-%d-%m-%Y")
        log_folder = self.script_path.parent / "Logs"
        log_folder.mkdir(parents=True, exist_ok=True)  # Create Logs folder if it doesn't exist
        log_file_name = f"Logs-{self.script_path.stem}-at-{current_datetime}.log"
        return log_folder / log_file_name

    def run_analysis(self):
        try:
            # Check script indentation
            self.check_total_lines()

            # Check script indentation
            self.check_indentation()

            # Check naming conventions
            self.check_naming_conventions()

            # Check modularization
            self.check_modularization()

            # Check file encoding
            self.check_file_encoding()

            # Check consistency
            self.check_consistency()

            # Check code reuse
            self.check_code_reuse()

            # Check whitespace usage
            self.check_whitespace()
            
            # # Check memory leakages (for C scripts)
            # if str(self.script_path).endswith(".cpp"):
            #     self.check_memory_leaks()
            # else:
            #     print("Script Cannot be analyzed for Memry Leaks.")

            # Print summary of the analysis results
            print("Script Analysis completed.")
            # Creating Log with Analysis in Log Directory    
            logging.info("Script Analysis completed.")
            
            # Email the log file
            sender_email = SENDER_EMAIL
            sender_password = SENDER_PASSWORD
            recipient_email = RECIPIENT_EMAIL
            attachment_path = self.log_file
            send_email(sender_email, sender_password, recipient_email, attachment_path)

        except Exception as e:
            logging.error(f"Error during analysis: {str(e)}")

    def check_total_lines(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()
                total_lines = len(lines)
                if total_lines > EXPECTED_LINE_COUNT:
                    logging.warning(f"Total number of lines ({total_lines}) exceeds the recommended maximum of 2000 lines.")
        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during total lines check: {str(e)}")

    def check_indentation(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                inside_function = False
                indentation_level = 0

                for line_number, line in enumerate(lines, start=1):
                    if not line.strip() or line.strip().startswith("//") or line.strip().startswith("/*"):
                        continue

                    if "\t" in line:
                        logging.warning(f"Indentation issue at line {line_number}: TAB space used. Convert TABs to spaces.")

                    if line.strip().startswith("#include"):
                        if not re.match(r'^#include\s+(<\S+\.h>|"\S+\.h")\s*$', line.strip()):
                            logging.warning(f"Syntax issue at line {line_number}: Incorrect syntax after #include.")
                        continue

                    if "{" in line and "(" in line and not inside_function:
                        if line.strip().endswith("{"):
                            inside_function = True
                            indentation_level += 1
                            continue

                    if inside_function:
                        control_structures = ["for", "while", "do", "if", "else", "elif", "elseif", "unless"]
                        for control_structure in control_structures:
                            if control_structure in line.strip():
                                if not line.startswith(" " * INDENTATION_SPACES * indentation_level):
                                    logging.warning(f"Indentation issue at line {line_number}: Incorrect indentation for {control_structure} statement.")
                                if line.strip().endswith("{"):
                                    indentation_level += 1
                            if "}" in line:
                                indentation_level -= 1
                                if indentation_level == 0:
                                    inside_function = False
                                    continue

                    if not line.startswith(" " * INDENTATION_SPACES * indentation_level):
                        logging.warning(f"Indentation issue at line {line_number}: Incorrect indentation.")

        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during indentation check: {str(e)}")

    def check_naming_conventions(self):
        try:
            processed_script = self.preprocess_cpp_file()
            ast = parse_file(processed_script)

            class NamingConventionVisitor(c_ast.NodeVisitor):
                def __init__(self):
                    self.module_prefix = None

                def visit_FileAST(self, node):
                    if node.ext:
                        for ext in node.ext:
                            if isinstance(ext, c_ast.Decl):
                                if ext.name and ext.name.startswith('MODULE_'):
                                    self.module_prefix = ext.name
                        self.generic_visit(node)

                def visit_FuncDef(self, node):
                    if not node.decl.name[0].islower():
                        logging.warning(f"Function {node.decl.name} does not start with a lowercase letter")
                    self.visit(node.body)

                def visit_Decl(self, node):
                    if isinstance(node.type, c_ast.TypeDecl):
                        if node.name.islower():
                            logging.warning(f"Variable {node.name} does not start with an uppercase letter")
                        elif node.name.upper() == node.name:
                            logging.warning(f"Constant {node.name} should not be all uppercase")
                        elif self.module_prefix and not node.name.startswith(self.module_prefix):
                            logging.warning(f"Symbol {node.name} should have a prefix '{self.module_prefix}'")
                    elif isinstance(node.type, c_ast.PtrDecl):
                        if not node.name.startswith('p_'):
                            logging.warning(f"Pointer variable {node.name} should start with 'p_'")
                    elif isinstance(node.type, c_ast.Struct):
                        if not node.name[0].isupper():
                            logging.warning(f"Type/Class {node.name} does not start with an uppercase letter")
                    self.generic_visit(node)

            v = NamingConventionVisitor()
            v.visit(ast)

        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during naming conventions check: {str(e)}")

    def preprocess_cpp_file(self):
        processed_file_path = self.script_path.parent / f"{self.script_path.stem}_processed.cpp"
        try:
            command = ['cpp', '-o', str(processed_file_path), str(self.script_path)]
            result = subprocess.run(command, check=True, capture_output=True, text=True)
        except subprocess.CalledProcessError as e:
            logging.error(f"Error during preprocessing: {e}")
            if e.stderr:
                logging.error(f"cpp error: {e.stderr}")
        except Exception as e:
            logging.error(f"Error during preprocessing: {str(e)}")

        return processed_file_path

    def check_modularization(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

            repeated_sequences = {}
            sequence_length = 3  # Minimum number of lines in a sequence to consider it for refactoring

            # Create sequences of lines
            for start_index in range(len(lines) - sequence_length + 1):
                sequence = tuple(lines[start_index:start_index + sequence_length])
                if all(len(line.strip()) > 1 for line in sequence):  # Check if all lines have more than one character
                    if sequence in repeated_sequences:
                        repeated_sequences[sequence].append(start_index + 1)  # Line numbers start from 1
                    else:
                        repeated_sequences[sequence] = [start_index + 1]

            # Determine the threshold for suggesting refactoring as a function
            repetition_threshold = 2

            for sequence, line_numbers in repeated_sequences.items():
                if len(line_numbers) >= repetition_threshold:
                    # Remove leading and trailing whitespace from the sequence for better readability in the log
                    formatted_sequence = ''.join(sequence).strip()
                    warning_message = f"Repetition detected: Sequence '{formatted_sequence}' repeated {len(line_numbers)} times. Consider refactoring as a function. Lines: {', '.join(map(str, line_numbers))}"
                    logging.warning(warning_message)

        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during modularization check: {str(e)}")


    def check_file_encoding(self):
        try:
            with open(self.script_path, "rb") as script_file:
                script_file.read().decode('utf-8')
        except UnicodeDecodeError as e:
            logging.error(f"File encoding issue: {str(e)} at {self.script_path}")

    def check_consistency(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                for line_number, line in enumerate(lines[:-1], start=1):
                    if not line.endswith(('\n', '\r\n', '\r')):
                        logging.warning(f"Consistency issue at line {line_number}: Inconsistent line ending.")

                last_line = lines[-1].strip()
                if last_line != "}":
                    logging.warning(f"Consistency issue: Incorrect syntax at the end of the file. Expected '}}', found '{last_line}'.")

        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during consistency check: {str(e)}")

    def check_code_reuse(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                for line_number, line in enumerate(lines, start=1):
                    if re.match(r'^\s*(import|require)\s+', line):
                        logging.warning(f"Code reuse issue at line {line_number}: Possible code duplication.")
        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during code reuse check: {str(e)}")

    def check_whitespace(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                for line_number, line in enumerate(lines, start=1):
                    if not line.strip() or line.strip().startswith("//") or line.strip().startswith("/*"):
                        continue

                    stripped_line = line.strip()
                    if '  ' in stripped_line:
                        logging.warning(f"Whitespace issue at line {line_number}: Excessive whitespace within line.")
                    if line.rstrip('\n').endswith(' '):
                        logging.warning(f"Whitespace issue at line {line_number}: Line ends with a space.")
        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during whitespace check: {str(e)}")
        
    def check_memory_leaks(self):
        try:
            cpp_file = str(self.script_path)
            executable_name = cpp_file.replace('.cpp', '.exe') if platform.system() == 'Windows' else cpp_file.replace('.cpp', '')

            try:
                if platform.system() == 'Windows':
                    result = subprocess.run(['g++', cpp_file, '-o', executable_name], check=True, capture_output=True, text=True)
                    if result.stderr:
                        logging.error(f"g++ error: {result.stderr}")
                    subprocess.check_call(['drmemory', '-logdir', 'logs', executable_name])
                else:
                    result = subprocess.run(['g++', cpp_file, '-o', executable_name], check=True, capture_output=True, text=True)
                    if result.stderr:
                        logging.error(f"g++ error: {result.stderr}")
                    valgrind_output = subprocess.check_output(['valgrind', '--leak-check=full', executable_name])
                    if 'no leaks are possible' not in valgrind_output.decode('utf-8'):
                        logging.warning("Memory leak detected!")
            except subprocess.CalledProcessError as e:
                logging.error(f"Error running memory leak check: {e}")
                return  # Exit the function early

        except FileNotFoundError:
            logging.error("Memory leak check tool not found. Please install the required tool.")
        except Exception as e:
            logging.error(f"Error checking memory leaks: {str(e)}")

def send_email(sender_email, sender_password, recipient_email, attachment_path):

    # Create a multipart message
    message = MIMEMultipart()
    message['From'] = sender_email
    message['To'] = recipient_email

    # Get the current date and format it as desired
    current_date = datetime.now().strftime('%Y-%m-%d')
    subject = f'Script Analyzer - {current_date}'  # Add current date to the subject
    message['Subject'] = subject

    # Add body text
    body = 'Please find the attached file.'
    message.attach(MIMEText(body, 'plain'))

    # Add attachment
    if attachment_path:
        attachment_filename = attachment_path.name
        attachment = open(attachment_path, "rb")
        part = MIMEBase('application', 'octet-stream')
        part.set_payload(attachment.read())
        encoders.encode_base64(part)
        part.add_header('Content-Disposition', f"attachment; filename= {attachment_filename}")
        message.attach(part)
        attachment.close()  # Close the file after reading

    # Connect to the SMTP server and send the email
    try:
        server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
        server.starttls()
        server.login(sender_email, sender_password)
        server.sendmail(sender_email, recipient_email, message.as_string())
        server.quit()
        print("Email sent successfully!")

    except (smtplib.SMTPException, IOError, OSError, Exception) as e:
        if isinstance(e, smtplib.SMTPException):
            print(f"Failed to send email: {e}")
        elif isinstance(e, IOError):
            print(f"I/O error occurred: {e}")
        elif isinstance(e, OSError):
            print(f"OS error occurred: {e}")
        else:
            print(f"Unexpected error: {e}")
        logging.error(f"Error occurred while sending email: {e}")

if __name__ == "__main__":
    script_path = input('Enter the Full Path to the Script that needs to be Reviewed (<Filename>.cpp)): \n')
    analyzer = ScriptAnalyzer(script_path)
    analyzer.run_analysis()
	
Enhance it in such a way that a user can remotely access this as a software.
What are the steps to get this in order. My intention is to have this on a system where the software can be hosted and all the user has do is to proved an input file
What would be the way for the end user to upload the file. How can this be logically worked on.
We need both 
- CLI access to upload the files to a specific folder in the system 
- GUI where the File can directly be uploaded - Probably we can use FLASK
- We can store the input cpp file that is uploaded or copied to into a particular location in the Server where the Script Analyzer is being hosted.
- We also need to get the Email to which the Logs need to be sent

------------------------------------
For GUI:

I created a directory called Project:
Path for Project: D:\Python\Coding_Standards\Project
Contents of Project folder are: Script_Analyzer.py, app.py and templates Folder
Contents of templates Folder: index.html

Contents of Script_Analyzer.py:
import re
import os
import logging
import subprocess
import smtplib
import platform
from pathlib import Path
from datetime import datetime
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
from pycparser import c_ast, parse_file

# Set global configuration values
SENDER_EMAIL = 'vaishnavi.m@thinkpalm.com'
SENDER_PASSWORD = 'Malu$123'
RECIPIENT_EMAIL = 'manu.m@thinkpalm.com'
SMTP_SERVER = 'smtp-mail.outlook.com'
SMTP_PORT = 587

# Set global indentation, line count and iteration values
INDENTATION_SPACES = 4
EXPECTED_LINE_COUNT = 2000
ITERATION_VALUES = {
    'MAX_FUNCTION_COUNT': 3,  # Maximum number of functions expected in the script
    'MAX_SUBROUTINE_COUNT': 3  # Maximum number of subroutines expected in the script
}

class ScriptAnalyzer:
    def __init__(self, script_path):
        self.script_path = Path(script_path)
        self.log_file = self.get_log_file_name()
        logging.basicConfig(filename=self.log_file, level=logging.INFO,
                            format='%(asctime)s - %(levelname)s - %(message)s')

    def get_log_file_name(self):
        current_datetime = datetime.now().strftime("%H-%M-%S-on-%d-%m-%Y")
        log_folder = self.script_path.parent / "Logs"
        log_folder.mkdir(parents=True, exist_ok=True)  # Create Logs folder if it doesn't exist
        log_file_name = f"Logs-{self.script_path.stem}-at-{current_datetime}.log"
        return log_folder / log_file_name

    def run_analysis(self):
        try:
            # Check script indentation
            self.check_total_lines()

            # Check script indentation
            self.check_indentation()

            # Check naming conventions
            self.check_naming_conventions()

            # Check modularization
            self.check_modularization()

            # Check file encoding
            self.check_file_encoding()

            # Check consistency
            self.check_consistency()

            # Check code reuse
            self.check_code_reuse()

            # Check whitespace usage
            self.check_whitespace()
            
            # # Check memory leakages (for C scripts)
            # if str(self.script_path).endswith(".cpp"):
            #     self.check_memory_leaks()
            # else:
            #     print("Script Cannot be analyzed for Memry Leaks.")

            # Print summary of the analysis results
            print("Script Analysis completed.")
            # Creating Log with Analysis in Log Directory    
            logging.info("Script Analysis completed.")
            
            # Email the log file
            sender_email = SENDER_EMAIL
            sender_password = SENDER_PASSWORD
            recipient_email = RECIPIENT_EMAIL
            attachment_path = self.log_file
            send_email(sender_email, sender_password, recipient_email, attachment_path)

        except Exception as e:
            logging.error(f"Error during analysis: {str(e)}")

    def check_total_lines(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()
                total_lines = len(lines)
                if total_lines > EXPECTED_LINE_COUNT:
                    logging.warning(f"Total number of lines ({total_lines}) exceeds the recommended maximum of 2000 lines.")
        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during total lines check: {str(e)}")

    def check_indentation(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                inside_function = False
                indentation_level = 0

                for line_number, line in enumerate(lines, start=1):
                    if not line.strip() or line.strip().startswith("//") or line.strip().startswith("/*"):
                        continue

                    if "\t" in line:
                        logging.warning(f"Indentation issue at line {line_number}: TAB space used. Convert TABs to spaces.")

                    if line.strip().startswith("#include"):
                        if not re.match(r'^#include\s+(<\S+\.h>|"\S+\.h")\s*$', line.strip()):
                            logging.warning(f"Syntax issue at line {line_number}: Incorrect syntax after #include.")
                        continue

                    if "{" in line and "(" in line and not inside_function:
                        if line.strip().endswith("{"):
                            inside_function = True
                            indentation_level += 1
                            continue

                    if inside_function:
                        control_structures = ["for", "while", "do", "if", "else", "elif", "elseif", "unless"]
                        for control_structure in control_structures:
                            if control_structure in line.strip():
                                if not line.startswith(" " * INDENTATION_SPACES * indentation_level):
                                    logging.warning(f"Indentation issue at line {line_number}: Incorrect indentation for {control_structure} statement.")
                                if line.strip().endswith("{"):
                                    indentation_level += 1
                            if "}" in line:
                                indentation_level -= 1
                                if indentation_level == 0:
                                    inside_function = False
                                    continue

                    if not line.startswith(" " * INDENTATION_SPACES * indentation_level):
                        logging.warning(f"Indentation issue at line {line_number}: Incorrect indentation.")

        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during indentation check: {str(e)}")

    def check_naming_conventions(self):
        try:
            processed_script = self.preprocess_cpp_file()
            ast = parse_file(processed_script)

            class NamingConventionVisitor(c_ast.NodeVisitor):
                def __init__(self):
                    self.module_prefix = None

                def visit_FileAST(self, node):
                    if node.ext:
                        for ext in node.ext:
                            if isinstance(ext, c_ast.Decl):
                                if ext.name and ext.name.startswith('MODULE_'):
                                    self.module_prefix = ext.name
                        self.generic_visit(node)

                def visit_FuncDef(self, node):
                    if not node.decl.name[0].islower():
                        logging.warning(f"Function {node.decl.name} does not start with a lowercase letter")
                    self.visit(node.body)

                def visit_Decl(self, node):
                    if isinstance(node.type, c_ast.TypeDecl):
                        if node.name.islower():
                            logging.warning(f"Variable {node.name} does not start with an uppercase letter")
                        elif node.name.upper() == node.name:
                            logging.warning(f"Constant {node.name} should not be all uppercase")
                        elif self.module_prefix and not node.name.startswith(self.module_prefix):
                            logging.warning(f"Symbol {node.name} should have a prefix '{self.module_prefix}'")
                    elif isinstance(node.type, c_ast.PtrDecl):
                        if not node.name.startswith('p_'):
                            logging.warning(f"Pointer variable {node.name} should start with 'p_'")
                    elif isinstance(node.type, c_ast.Struct):
                        if not node.name[0].isupper():
                            logging.warning(f"Type/Class {node.name} does not start with an uppercase letter")
                    self.generic_visit(node)

            v = NamingConventionVisitor()
            v.visit(ast)

        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during naming conventions check: {str(e)}")

    def preprocess_cpp_file(self):
        processed_file_path = self.script_path.parent / f"{self.script_path.stem}_processed.cpp"
        try:
            command = ['cpp', '-o', str(processed_file_path), str(self.script_path)]
            result = subprocess.run(command, check=True, capture_output=True, text=True)
        except subprocess.CalledProcessError as e:
            logging.error(f"Error during preprocessing: {e}")
            if e.stderr:
                logging.error(f"cpp error: {e.stderr}")
        except Exception as e:
            logging.error(f"Error during preprocessing: {str(e)}")

        return processed_file_path

    def check_modularization(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

            repeated_sequences = {}
            sequence_length = 3  # Minimum number of lines in a sequence to consider it for refactoring

            # Create sequences of lines
            for start_index in range(len(lines) - sequence_length + 1):
                sequence = tuple(lines[start_index:start_index + sequence_length])
                if all(len(line.strip()) > 1 for line in sequence):  # Check if all lines have more than one character
                    if sequence in repeated_sequences:
                        repeated_sequences[sequence].append(start_index + 1)  # Line numbers start from 1
                    else:
                        repeated_sequences[sequence] = [start_index + 1]

            # Determine the threshold for suggesting refactoring as a function
            repetition_threshold = 2

            for sequence, line_numbers in repeated_sequences.items():
                if len(line_numbers) >= repetition_threshold:
                    # Remove leading and trailing whitespace from the sequence for better readability in the log
                    formatted_sequence = ''.join(sequence).strip()
                    warning_message = f"Repetition detected: Sequence '{formatted_sequence}' repeated {len(line_numbers)} times. Consider refactoring as a function. Lines: {', '.join(map(str, line_numbers))}"
                    logging.warning(warning_message)

        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during modularization check: {str(e)}")


    def check_file_encoding(self):
        try:
            with open(self.script_path, "rb") as script_file:
                script_file.read().decode('utf-8')
        except UnicodeDecodeError as e:
            logging.error(f"File encoding issue: {str(e)} at {self.script_path}")

    def check_consistency(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                for line_number, line in enumerate(lines[:-1], start=1):
                    if not line.endswith(('\n', '\r\n', '\r')):
                        logging.warning(f"Consistency issue at line {line_number}: Inconsistent line ending.")

                last_line = lines[-1].strip()
                if last_line != "}":
                    logging.warning(f"Consistency issue: Incorrect syntax at the end of the file. Expected '}}', found '{last_line}'.")

        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during consistency check: {str(e)}")

    def check_code_reuse(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                for line_number, line in enumerate(lines, start=1):
                    if re.match(r'^\s*(import|require)\s+', line):
                        logging.warning(f"Code reuse issue at line {line_number}: Possible code duplication.")
        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during code reuse check: {str(e)}")

    def check_whitespace(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                for line_number, line in enumerate(lines, start=1):
                    if not line.strip() or line.strip().startswith("//") or line.strip().startswith("/*"):
                        continue

                    stripped_line = line.strip()
                    if '  ' in stripped_line:
                        logging.warning(f"Whitespace issue at line {line_number}: Excessive whitespace within line.")
                    if line.rstrip('\n').endswith(' '):
                        logging.warning(f"Whitespace issue at line {line_number}: Line ends with a space.")
        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during whitespace check: {str(e)}")
        
    def check_memory_leaks(self):
        try:
            cpp_file = str(self.script_path)
            executable_name = cpp_file.replace('.cpp', '.exe') if platform.system() == 'Windows' else cpp_file.replace('.cpp', '')

            try:
                if platform.system() == 'Windows':
                    result = subprocess.run(['g++', cpp_file, '-o', executable_name], check=True, capture_output=True, text=True)
                    if result.stderr:
                        logging.error(f"g++ error: {result.stderr}")
                    subprocess.check_call(['drmemory', '-logdir', 'logs', executable_name])
                else:
                    result = subprocess.run(['g++', cpp_file, '-o', executable_name], check=True, capture_output=True, text=True)
                    if result.stderr:
                        logging.error(f"g++ error: {result.stderr}")
                    valgrind_output = subprocess.check_output(['valgrind', '--leak-check=full', executable_name])
                    if 'no leaks are possible' not in valgrind_output.decode('utf-8'):
                        logging.warning("Memory leak detected!")
            except subprocess.CalledProcessError as e:
                logging.error(f"Error running memory leak check: {e}")
                return  # Exit the function early

        except FileNotFoundError:
            logging.error("Memory leak check tool not found. Please install the required tool.")
        except Exception as e:
            logging.error(f"Error checking memory leaks: {str(e)}")

def send_email(sender_email, sender_password, recipient_email, attachment_path):

    # Create a multipart message
    message = MIMEMultipart()
    message['From'] = sender_email
    message['To'] = recipient_email

    # Get the current date and format it as desired
    current_date = datetime.now().strftime('%Y-%m-%d')
    subject = f'Script Analyzer - {current_date}'  # Add current date to the subject
    message['Subject'] = subject

    # Add body text
    body = 'Please find the attached file.'
    message.attach(MIMEText(body, 'plain'))

    # Add attachment
    if attachment_path:
        attachment_filename = attachment_path.name
        attachment = open(attachment_path, "rb")
        part = MIMEBase('application', 'octet-stream')
        part.set_payload(attachment.read())
        encoders.encode_base64(part)
        part.add_header('Content-Disposition', f"attachment; filename= {attachment_filename}")
        message.attach(part)
        attachment.close()  # Close the file after reading

    # Connect to the SMTP server and send the email
    try:
        server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
        server.starttls()
        server.login(sender_email, sender_password)
        server.sendmail(sender_email, recipient_email, message.as_string())
        server.quit()
        print("Email sent successfully!")

    except (smtplib.SMTPException, IOError, OSError, Exception) as e:
        if isinstance(e, smtplib.SMTPException):
            print(f"Failed to send email: {e}")
        elif isinstance(e, IOError):
            print(f"I/O error occurred: {e}")
        elif isinstance(e, OSError):
            print(f"OS error occurred: {e}")
        else:
            print(f"Unexpected error: {e}")
        logging.error(f"Error occurred while sending email: {e}")

if __name__ == "__main__":
    script_path = input('Enter the Full Path to the Script that needs to be Reviewed (<Filename>.cpp)): \n')
    analyzer = ScriptAnalyzer(script_path)
    analyzer.run_analysis()

Contents of app.py:
from flask import Flask, render_template, request
from Script_Analyzer import ScriptAnalyzer, send_email
import os

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = 'uploads'  # Folder where uploaded files will be stored

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/upload', methods=['POST'])
def upload_file():
    uploaded_file = request.files['file']
    if uploaded_file.filename != '':
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], uploaded_file.filename)
        uploaded_file.save(file_path)

        recipient_email = request.form['recipient_email']  # Get recipient email from form input
        analyzer = ScriptAnalyzer(file_path)
        analyzer.run_analysis()
        send_email(analyzer.log_file, recipient_email)  # Send email with log file to the specified recipient
        return f'Analysis complete. Log file sent to {recipient_email}'
    else:
        return 'No file uploaded'

if __name__ == '__main__':
    app.run(debug=True)

Contents of index.html:
<!DOCTYPE html>
<html>
<head>
    <title>Script Analyzer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        .container {
            width: 80%;
            max-width: 600px;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            color: #333;
        }
        form {
            margin-top: 20px;
            text-align: center;
        }
        input[type="file"] {
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 80%;
        }
        input[type="submit"] {
            background-color: #007bff;
            color: #fff;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        input[type="submit"]:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Script Analyzer</h1>
        <form method="POST" action="/upload" enctype="multipart/form-data">
            <input type="file" name="file">
            <br>
            <input type="submit" value="Upload">
        </form>
    </div>
</body>
</html>


--------------------------------------

Script_Analyzer.py

import re
import os
import logging
import subprocess
import smtplib
import platform
from pathlib import Path
from datetime import datetime
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
from pycparser import c_ast, parse_file

# Set global configuration values
SENDER_EMAIL = 'vaishnavi.m@thinkpalm.com'
SENDER_PASSWORD = 'Malu$123'
RECIPIENT_EMAIL = 'manu.m@thinkpalm.com'
SMTP_SERVER = 'smtp-mail.outlook.com'
SMTP_PORT = 587

# Set global indentation, line count, and iteration values
INDENTATION_SPACES = 4
EXPECTED_LINE_COUNT = 2000
ITERATION_VALUES = {
    'MAX_FUNCTION_COUNT': 3,  # Maximum number of functions expected in the script
    'MAX_SUBROUTINE_COUNT': 3  # Maximum number of subroutines expected in the script
}

class ScriptAnalyzer:
    def __init__(self, script_path):
        self.script_path = Path(script_path)
        self.log_file = self.get_log_file_name()
        logging.basicConfig(filename=self.log_file, level=logging.INFO,
                            format='%(asctime)s - %(levelname)s - %(message)s')

    def get_log_file_name(self):
        current_datetime = datetime.now().strftime("%H-%M-%S-on-%d-%m-%Y")
        log_folder = self.script_path.parent / "Logs"
        log_folder.mkdir(parents=True, exist_ok=True)  # Create Logs folder if it doesn't exist
        log_file_name = f"Logs-{self.script_path.stem}-at-{current_datetime}.log"
        return log_folder / log_file_name

    def run_analysis(self):
        try:
            # Check script indentation
            self.check_total_lines()

            # Check script indentation
            self.check_indentation()

            # Check naming conventions
            self.check_naming_conventions()

            # Check modularization
            self.check_modularization()

            # Check file encoding
            self.check_file_encoding()

            # Check consistency
            self.check_consistency()

            # Check code reuse
            self.check_code_reuse()

            # Check whitespace usage
            self.check_whitespace()

            # Print summary of the analysis results
            print("Script Analysis completed.")
            # Creating Log with Analysis in Log Directory
            logging.info("Script Analysis completed.")

            # Email the log file
            sender_email = SENDER_EMAIL
            sender_password = SENDER_PASSWORD
            recipient_email = RECIPIENT_EMAIL
            attachment_path = self.log_file
            send_email(sender_email, sender_password, recipient_email, attachment_path)

        except Exception as e:
            logging.error(f"Error during analysis: {str(e)}")

    def check_total_lines(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()
                total_lines = len(lines)
                if total_lines > EXPECTED_LINE_COUNT:
                    logging.warning(f"Total number of lines ({total_lines}) exceeds the recommended maximum of 2000 lines.")
        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during total lines check: {str(e)}")

    def check_indentation(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                inside_function = False
                indentation_level = 0

                for line_number, line in enumerate(lines, start=1):
                    if not line.strip() or line.strip().startswith("//") or line.strip().startswith("/*"):
                        continue

                    if "\t" in line:
                        logging.warning(f"Indentation issue at line {line_number}: TAB space used. Convert TABs to spaces.")

                    if line.strip().startswith("#include"):
                        if not re.match(r'^#include\s+(<\S+\.h>|"\S+\.h")\s*$', line.strip()):
                            logging.warning(f"Syntax issue at line {line_number}: Incorrect syntax after #include.")
                        continue

                    if "{" in line and "(" in line and not inside_function:
                        if line.strip().endswith("{"):
                            inside_function = True
                            indentation_level += 1
                            continue

                    if inside_function:
                        control_structures = ["for", "while", "do", "if", "else", "elif", "elseif", "unless"]
                        for control_structure in control_structures:
                            if control_structure in line.strip():
                                if not line.startswith(" " * INDENTATION_SPACES * indentation_level):
                                    logging.warning(f"Indentation issue at line {line_number}: Incorrect indentation for {control_structure} statement.")
                                if line.strip().endswith("{"):
                                    indentation_level += 1
                            if "}" in line:
                                indentation_level -= 1
                                if indentation_level == 0:
                                    inside_function = False
                                    continue

                    if not line.startswith(" " * INDENTATION_SPACES * indentation_level):
                        logging.warning(f"Indentation issue at line {line_number}: Incorrect indentation.")

        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during indentation check: {str(e)}")

    def check_naming_conventions(self):
        try:
            processed_script = self.preprocess_cpp_file()
            ast = parse_file(processed_script)

            class NamingConventionVisitor(c_ast.NodeVisitor):
                def __init__(self):
                    self.module_prefix = None

                def visit_FileAST(self, node):
                    if node.ext:
                        for ext in node.ext:
                            if isinstance(ext, c_ast.Decl):
                                if ext.name and ext.name.startswith('MODULE_'):
                                    self.module_prefix = ext.name
                        self.generic_visit(node)

                def visit_FuncDef(self, node):
                    if not node.decl.name[0].islower():
                        logging.warning(f"Function {node.decl.name} does not start with a lowercase letter")
                    self.visit(node.body)

                def visit_Decl(self, node):
                    if isinstance(node.type, c_ast.TypeDecl):
                        if node.name.islower():
                            logging.warning(f"Variable {node.name} does not start with an uppercase letter")
                        elif node.name.upper() == node.name:
                            logging.warning(f"Constant {node.name} should not be all uppercase")
                        elif self.module_prefix and not node.name.startswith(self.module_prefix):
                            logging.warning(f"Symbol {node.name} should have a prefix '{self.module_prefix}'")
                    elif isinstance(node.type, c_ast.PtrDecl):
                        if not node.name.startswith('p_'):
                            logging.warning(f"Pointer variable {node.name} should start with 'p_'")
                    elif isinstance(node.type, c_ast.Struct):
                        if not node.name[0].isupper():
                            logging.warning(f"Type/Class {node.name} does not start with an uppercase letter")
                    self.generic_visit(node)

            v = NamingConventionVisitor()
            v.visit(ast)

        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during naming conventions check: {str(e)}")

    def preprocess_cpp_file(self):
        processed_file_path = self.script_path.parent / f"{self.script_path.stem}_processed.cpp"
        try:
            command = ['cpp', '-o', str(processed_file_path), str(self.script_path)]
            result = subprocess.run(command, check=True, capture_output=True, text=True)
        except subprocess.CalledProcessError as e:
            logging.error(f"Error during preprocessing: {e}")
            if e.stderr:
                logging.error(f"cpp error: {e.stderr}")
        except Exception as e:
            logging.error(f"Error during preprocessing: {str(e)}")

        return processed_file_path

    def check_modularization(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

            repeated_sequences = {}
            sequence_length = 3  # Minimum number of lines in a sequence to consider it for refactoring

            # Create sequences of lines
            for start_index in range(len(lines) - sequence_length + 1):
                sequence = tuple(lines[start_index:start_index + sequence_length])
                if all(len(line.strip()) > 1 for line in sequence):  # Check if all lines have more than one character
                    if sequence in repeated_sequences:
                        repeated_sequences[sequence].append(start_index + 1)  # Line numbers start from 1
                    else:
                        repeated_sequences[sequence] = [start_index + 1]

            # Determine the threshold for suggesting refactoring as a function
            repetition_threshold = 2

            for sequence, line_numbers in repeated_sequences.items():
                if len(line_numbers) >= repetition_threshold:
                    # Remove leading and trailing whitespace from the sequence for better readability in the log
                    formatted_sequence = ''.join(sequence).strip()
                    warning_message = f"Repetition detected: Sequence '{formatted_sequence}' repeated {len(line_numbers)} times. Consider refactoring as a function. Lines: {', '.join(map(str, line_numbers))}"
                    logging.warning(warning_message)

        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during modularization check: {str(e)}")

    def check_file_encoding(self):
        try:
            with open(self.script_path, "rb") as script_file:
                script_file.read().decode('utf-8')
        except UnicodeDecodeError as e:
            logging.error(f"File encoding issue: {str(e)} at {self.script_path}")

    def check_consistency(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                for line_number, line in enumerate(lines[:-1], start=1):
                    if not line.endswith(('\n', '\r\n', '\r')):
                        logging.warning(f"Consistency issue at line {line_number}: Inconsistent line ending.")

                last_line = lines[-1].strip()
                if last_line != "}":
                    logging.warning(f"Consistency issue: Incorrect syntax at the end of the file. Expected '}}', found '{last_line}'.")

        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during consistency check: {str(e)}")

    def check_code_reuse(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                for line_number, line in enumerate(lines, start=1):
                    if re.match(r'^\s*(import|require)\s+', line):
                        logging.warning(f"Code reuse issue at line {line_number}: Possible code duplication.")
        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during code reuse check: {str(e)}")

    def check_whitespace(self):
        try:
            with open(self.script_path, "r") as script_file:
                lines = script_file.readlines()

                for line_number, line in enumerate(lines, start=1):
                    if not line.strip() or line.strip().startswith("//") or line.strip().startswith("/*"):
                        continue

                    stripped_line = line.strip()
                    if '  ' in stripped_line:
                        logging.warning(f"Whitespace issue at line {line_number}: Excessive whitespace within line.")
                    if line.rstrip('\n').endswith(' '):
                        logging.warning(f"Whitespace issue at line {line_number}: Line ends with a space.")
        except FileNotFoundError:
            logging.error(f"File not found: {self.script_path}")
        except Exception as e:
            logging.error(f"Error during whitespace check: {str(e)}")

    def check_memory_leaks(self):
        try:
            cpp_file = str(self.script_path)
            executable_name = cpp_file.replace('.cpp', '.exe') if platform.system() == 'Windows' else cpp_file.replace('.cpp', '')

            try:
                if platform.system() == 'Windows':
                    result = subprocess.run(['g++', cpp_file, '-o', executable_name], check=True, capture_output=True, text=True)
                    if result.stderr:
                        logging.error(f"g++ error: {result.stderr}")
                    subprocess.check_call(['drmemory', '-logdir', 'logs', executable_name])
                else:
                    result = subprocess.run(['g++', cpp_file, '-o', executable_name], check=True, capture_output=True, text=True)
                    if result.stderr:
                        logging.error(f"g++ error: {result.stderr}")
                    valgrind_output = subprocess.check_output(['valgrind', '--leak-check=full', executable_name])
                    if 'no leaks are possible' not in valgrind_output.decode('utf-8'):
                        logging.warning("Memory leak detected!")
            except subprocess.CalledProcessError as e:
                logging.error(f"Error running memory leak check: {e}")
                return  # Exit the function early

        except FileNotFoundError:
            logging.error("Memory leak check tool not found. Please install the required tool.")
        except Exception as e:
            logging.error(f"Error checking memory leaks: {str(e)}")

def send_email(sender_email, sender_password, recipient_email, attachment_path):

    # Create a multipart message
    message = MIMEMultipart()
    message['From'] = sender_email
    message['To'] = recipient_email

    # Get the current date and format it as desired
    current_date = datetime.now().strftime('%Y-%m-%d')
    subject = f"Script Analysis Log - {current_date}"
    message['Subject'] = subject

    # Add body to email
    body = "Please find attached the log file for the script analysis."
    message.attach(MIMEText(body, 'plain'))

    # Open the file to be sent
    filename = os.path.basename(attachment_path)
    attachment = open(attachment_path, "rb")

    # Add file as application/octet-stream
    part = MIMEBase("application", "octet-stream")
    part.set_payload(attachment.read())
    encoders.encode_base64(part)

    # Add header as key/value pair to attachment part
    part.add_header(
        "Content-Disposition",
        f"attachment; filename= {filename}",
    )

    # Add attachment to message and convert message to string
    message.attach(part)
    text = message.as_string()

    # Log into server and send email
    server = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)
    server.starttls()
    server.login(sender_email, sender_password)
    server.sendmail(sender_email, recipient_email, text)
    server.quit()

if __name__ == "__main__":
    script_path = input("Enter the path to the C++ script you want to analyze: ")
    analyzer = ScriptAnalyzer(script_path)
    analyzer.run_analysis()

app.py:

from flask import Flask, render_template, request, redirect, url_for, flash
from werkzeug.utils import secure_filename
from Script_Analyzer import ScriptAnalyzer, send_email

app = Flask(__name__)
app.secret_key = 'supersecretkey'
app.config['UPLOAD_FOLDER'] = 'uploads'
ALLOWED_EXTENSIONS = {'cpp'}

# Set global configuration values
SENDER_EMAIL = 'vaishnavi.m@thinkpalm.com'
SENDER_PASSWORD = 'Malu$123'
SMTP_SERVER = 'smtp-mail.outlook.com'
SMTP_PORT = 587

@app.route('/')
def index():
    return render_template('index.html')

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

@app.route('/upload', methods=['POST'])
def upload_file():
    recipient_email = request.form['recipient_email']
    if 'file' not in request.files:
        flash('No file part')
        return redirect(request.url)
    file = request.files['file']
    if file.filename == '':
        flash('No selected file')
        return redirect(request.url)
    if file and allowed_file(file.filename):
        filename = secure_filename(file.filename)
        file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        analyzer = ScriptAnalyzer(file_path)
        analyzer.run_analysis(recipient_email)
        flash('File successfully uploaded and analyzed')
        return redirect(url_for('index'))
    else:
        flash('Allowed file types are .cpp')
        return redirect(request.url)

if __name__ == '__main__':
    app.run(debug=True)


index.html:

<!DOCTYPE html>
<html>
<head>
    <title>Script Analyzer</title>
    <style>
        body {
            background-color: #2c3e50; /* Dark blue background */
            color: #ecf0f1; /* Light text color */
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }

        h1 {
            color: #3498db; /* Blue heading color */
            text-align: center;
            margin-top: 20px;
        }

        form {
            max-width: 500px;
            margin: 20px auto;
            padding: 20px;
            background-color: #34495e; /* Darker blue form background */
            border-radius: 5px;
        }

        label {
            color: #ecf0f1; /* Light label text color */
        }

        input[type="email"],
        input[type="file"],
        input[type="submit"] {
            width: 100%;
            padding: 10px;
            margin-top: 5px;
            margin-bottom: 10px;
            box-sizing: border-box;
            border: none;
            border-radius: 3px;
        }

        input[type="submit"] {
            background-color: #3498db; /* Blue submit button */
            color: #ecf0f1; /* Light text color */
            cursor: pointer;
        }

        input[type="submit"]:hover {
            background-color: #2980b9; /* Darker blue on hover */
        }

        ul {
            list-style-type: none;
            padding: 0;
        }

        li {
            color: #f39c12; /* Orange message text color */
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <h1>Script Analyzer</h1>
    <form method="post" action="/upload" enctype="multipart/form-data">
        <label for="recipient_email">Recipient Email Address:</label><br>
        <input type="email" id="recipient_email" name="recipient_email"><br><br>
        <label for="file">Select a C++ file:</label><br>
        <input type="file" id="file" name="file"><br><br>
        <input type="submit" value="Submit">
    </form>
    {% with messages = get_flashed_messages() %}
      {% if messages %}
        <ul>
          {% for message in messages %}
            <li>{{ message }}</li>
          {% endfor %}
        </ul>
      {% endif %}
    {% endwith %}
</body>
</html>


-----------------------------------------------------------------------

I have accessed the GUI:

There are two sections:
Section on Top:
Heading: Script Analyzer
<A box and a button to upload below>
1. Recipient Email Address: A box to enter the recipient email Address
2. Select a C++ file: A place to upload the Cpp file 
Submit Button

Section Below this:
Left Aligned heading: Analyze Script
<Two Boxes Below: to enter data>
1. Recipient Email Address: A box to enter the recipient email Address
2. Enter script path: A box to enter the Script Path
Analyze Button

Modification that needs to be done in index.html is that the GUI needs only:

Heading: Script Analyzer
<A box and a button to upload below>
1. Recipient Email Address: A box to enter the recipient email Address
2. Select a C++ file: A place to upload the Cpp file 
Submit Button
- Implement a Progress Button to show progress of the upload with a max of 5 seconds

my Script_Analyzer.py is actually meant to accept the path of the CPP code.
We need to handle it in such a way that since the GUI accepts only the recipient_email and Upload the CPP file.
Enhancement --> Upload file should be copied directly to the folder where the Analyzer will be able to execute it.
To handle this the Folder must be created incase the folder isnt present to where the uploads need to be stored and Analyzed as well.
As written earlier, we need to get the user input of recipient_email and use this to send logs of the analysis to the mentioned recipient_email
Please make edits to the app.py file first.

my Script_Analyzer.py is initally meant to accept the path of the CPP code.
As intended in index.html and app.py, we need to make necessary edits to handle the CPP file that the user uploads via GUI.
script_path was initially a user input, we need to handle this so that the file uploaded in the uploads folder created, needs to be used as input and analysis, log creation and email generation from there on.
Is this possible based on the code in the start of this msg?

One thing i notice is that, when we log into GUI, we see the POP up msg even before the email is entered or the file is uploaded: "File successfully uploaded and analyzed". How can we avoid this from happening?

can we add an enhancement. Once script is uploaded a pop up saying Upload completed and needs to be closed in three seconds
Again once analysis is in progress, We can have a progress bar for the same and once that is done, we can have a Pop up saying Analysis complete and Email with Logs sent to <Recipients Email>

